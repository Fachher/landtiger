//#include <math.h>
#include "ST7735.h"
#include "helper.h"
#include "gpio.h"
#include "spi.h"

#define CHIP_SELECT 0
#define COMMAND 1 // data or command
#define RESET 10

/* Font files. Thanks Adafruit!
 * We (might) have to split out fonts in to two or more
 * arrays. Most devices have a limit of one RAM bank per
 * which is probably 256 bytes.
 */
extern const char Font1[] = {
        0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x5F, 0x00, 0x00,
        0x00, 0x07, 0x00, 0x07, 0x00,
        0x14, 0x7F, 0x14, 0x7F, 0x14,
        0x24, 0x2A, 0x7F, 0x2A, 0x12,
        0x23, 0x13, 0x08, 0x64, 0x62,
        0x36, 0x49, 0x56, 0x20, 0x50,
        0x00, 0x08, 0x07, 0x03, 0x00,
        0x00, 0x1C, 0x22, 0x41, 0x00,
        0x00, 0x41, 0x22, 0x1C, 0x00,
        0x2A, 0x1C, 0x7F, 0x1C, 0x2A,
        0x08, 0x08, 0x3E, 0x08, 0x08,
        0x00, 0x80, 0x70, 0x30, 0x00,
        0x08, 0x08, 0x08, 0x08, 0x08,
        0x00, 0x00, 0x60, 0x60, 0x00,
        0x20, 0x10, 0x08, 0x04, 0x02,
        0x3E, 0x51, 0x49, 0x45, 0x3E,
        0x00, 0x42, 0x7F, 0x40, 0x00,
        0x72, 0x49, 0x49, 0x49, 0x46,
        0x21, 0x41, 0x49, 0x4D, 0x33,
        0x18, 0x14, 0x12, 0x7F, 0x10,
        0x27, 0x45, 0x45, 0x45, 0x39,
        0x3C, 0x4A, 0x49, 0x49, 0x31,
        0x41, 0x21, 0x11, 0x09, 0x07,
        0x36, 0x49, 0x49, 0x49, 0x36,
        0x46, 0x49, 0x49, 0x29, 0x1E,
        0x00, 0x00, 0x14, 0x00, 0x00,
        0x00, 0x40, 0x34, 0x00, 0x00,
        0x00, 0x08, 0x14, 0x22, 0x41,
        0x14, 0x14, 0x14, 0x14, 0x14,
        0x00, 0x41, 0x22, 0x14, 0x08,
        0x02, 0x01, 0x59, 0x09, 0x06,
        0x3E, 0x41, 0x5D, 0x59, 0x4E,
        0x7C, 0x12, 0x11, 0x12, 0x7C,
        0x7F, 0x49, 0x49, 0x49, 0x36,
        0x3E, 0x41, 0x41, 0x41, 0x22,
        0x7F, 0x41, 0x41, 0x41, 0x3E,
        0x7F, 0x49, 0x49, 0x49, 0x41,
        0x7F, 0x09, 0x09, 0x09, 0x01,
        0x3E, 0x41, 0x41, 0x51, 0x73,
        0x7F, 0x08, 0x08, 0x08, 0x7F,
        0x00, 0x41, 0x7F, 0x41, 0x00,
        0x20, 0x40, 0x41, 0x3F, 0x01,
        0x7F, 0x08, 0x14, 0x22, 0x41,
        0x7F, 0x40, 0x40, 0x40, 0x40,
        0x7F, 0x02, 0x1C, 0x02, 0x7F,
        0x7F, 0x04, 0x08, 0x10, 0x7F,
        0x3E, 0x41, 0x41, 0x41, 0x3E,
        0x7F, 0x09, 0x09, 0x09, 0x06,
        0x3E, 0x41, 0x51, 0x21, 0x5E,
        0x7F, 0x09, 0x19, 0x29, 0x46
};
extern const char Font2[] = {
        0x26, 0x49, 0x49, 0x49, 0x32,
        0x03, 0x01, 0x7F, 0x01, 0x03,
        0x3F, 0x40, 0x40, 0x40, 0x3F,
        0x1F, 0x20, 0x40, 0x20, 0x1F,
        0x3F, 0x40, 0x38, 0x40, 0x3F,
        0x63, 0x14, 0x08, 0x14, 0x63,
        0x03, 0x04, 0x78, 0x04, 0x03,
        0x61, 0x59, 0x49, 0x4D, 0x43,
        0x00, 0x7F, 0x41, 0x41, 0x41,
        0x02, 0x04, 0x08, 0x10, 0x20,
        0x00, 0x41, 0x41, 0x41, 0x7F,
        0x04, 0x02, 0x01, 0x02, 0x04,
        0x40, 0x40, 0x40, 0x40, 0x40,
        0x00, 0x03, 0x07, 0x08, 0x00,
        0x20, 0x54, 0x54, 0x78, 0x40,
        0x7F, 0x28, 0x44, 0x44, 0x38,
        0x38, 0x44, 0x44, 0x44, 0x28,
        0x38, 0x44, 0x44, 0x28, 0x7F,
        0x38, 0x54, 0x54, 0x54, 0x18,
        0x00, 0x08, 0x7E, 0x09, 0x02,
        0x18, 0xA4, 0xA4, 0x9C, 0x78,
        0x7F, 0x08, 0x04, 0x04, 0x78,
        0x00, 0x44, 0x7D, 0x40, 0x00,
        0x20, 0x40, 0x40, 0x3D, 0x00,
        0x7F, 0x10, 0x28, 0x44, 0x00,
        0x00, 0x41, 0x7F, 0x40, 0x00,
        0x7C, 0x04, 0x78, 0x04, 0x78,
        0x7C, 0x08, 0x04, 0x04, 0x78,
        0x38, 0x44, 0x44, 0x44, 0x38,
        0xFC, 0x18, 0x24, 0x24, 0x18,
        0x18, 0x24, 0x24, 0x18, 0xFC,
        0x7C, 0x08, 0x04, 0x04, 0x08,
        0x48, 0x54, 0x54, 0x54, 0x24,
        0x04, 0x04, 0x3F, 0x44, 0x24,
        0x3C, 0x40, 0x40, 0x20, 0x7C,
        0x1C, 0x20, 0x40, 0x20, 0x1C,
        0x3C, 0x40, 0x30, 0x40, 0x3C,
        0x44, 0x28, 0x10, 0x28, 0x44,
        0x4C, 0x90, 0x90, 0x90, 0x7C,
        0x44, 0x64, 0x54, 0x4C, 0x44,
        0x00, 0x08, 0x36, 0x41, 0x00,
        0x00, 0x00, 0x77, 0x00, 0x00,
        0x00, 0x41, 0x36, 0x08, 0x00,
        0x24, 0x66, 0xE7, 0x66, 0x24
};

//Some bitmaps (see bitmap function for description)
//First to integers are width, height respectively.
extern unsigned int testBMP[] = {8, 8,
                          0xAAAA, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000, 0x5555,
                          0x0000, 0xAAAA, 0x000F, 0x00F0, 0x0F00, 0xF000, 0x5555, 0x0000,
                          0x0000, 0x0000, 0x00FF, 0x0FF0, 0xFF00, 0xF00F, 0x0000, 0x0000,
                          0x0000, 0x0000, 0x0FFF, 0xFFF0, 0xFF0F, 0xF0FF, 0x0000, 0x0000,
                          0x0000, 0x0000, 0xF0F0, 0x0F0F, 0xFFFF, 0xFFFF, 0x0000, 0x0000,
                          0x0000, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000, 0x0000,
                          0x0000, 0x5555, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xAAAA, 0x0000,
                          0x5555, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000, 0xAAAA
};

extern unsigned int downArrowBMP[] = {8, 4,
                               0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF,
                               0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000,
                               0x0000, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000, 0x0000,
                               0x0000, 0x0000, 0x0000, 0xFFFF, 0xFFFF, 0x0000, 0x0000, 0x0000
};



void lcd_write_data(unsigned char data) {
    digitalWritePort0(CHIP_SELECT, 0);
    spi_write(data);
    digitalWritePort0(CHIP_SELECT, 1);
}

void lcd_write_command(unsigned char data) {
    digitalWritePort0(COMMAND, 0);
    digitalWritePort0(CHIP_SELECT, 0);
    spi_write(data);
    digitalWritePort0(COMMAND, 1);
    digitalWritePort0(CHIP_SELECT, 1);
}

void lcd_init() {
    digitalWritePort0(CHIP_SELECT, 1);
    digitalWritePort0(COMMAND, 1);
    digitalWritePort0(RESET, 1);
    //Cycle reset pin
    digitalWritePort0(RESET, 0);
    delay(500);
    digitalWritePort0(RESET, 1);
    delay(500);
    lcd_init_command_list();
}

void lcd_init_command_list(void)
{
    lcd_write_command(ST7735_SWRESET);
    delay(100);
    lcd_write_command(0x11);//Sleep out
    delay(120);

    lcd_write_command(0x3A);
    lcd_write_data(0x05);
    lcd_write_command(0x29);//Display on
}

void draw_pixel(char x, char y, unsigned int colour) {
    set_draw_window(x, y, x+1, y+1);
    lcd_write_data(colour >> 8);
    lcd_write_data(colour & 0xFF);
}

void fill_rectangle(char x1, char y1, char x2, char y2, unsigned int colour) {

    unsigned char colour_high = colour >> 8;
    unsigned char colour_low = colour & 0xFF;

    //Set the drawing region
    set_draw_window(x1, y1, x2, y2);

    digitalWritePort0(CHIP_SELECT, 0);
    //Write colour to each pixel
    for(int y = 0; y < y2-y1+1 ; y++) {
        for(int x = 0; x < x2-x1+1; x++) {
            spi_write(colour_high);
            spi_write(colour_low);
        }
    }
    digitalWritePort0(CHIP_SELECT, 1);
}

void set_draw_window(char x1, char y1, char x2, char y2) {
    lcd_write_command(ST7735_CASET);
    lcd_write_data(0x00);
    lcd_write_data(x1);
    lcd_write_data(0x00);
    lcd_write_data(x2);

    lcd_write_command(ST7735_RASET);
    lcd_write_data(0x00);
    lcd_write_data(y1);
    lcd_write_data(0x00);
    lcd_write_data(y2);

    lcd_write_command(ST7735_RAMWR);
}

void draw_char(char x, char y, char c, unsigned int colour, char size){
    int i, j;
    char line;
    unsigned int font_index = (c - 32) * 5;

    //Get the line of pixels from the font file
    for(i=0; i<5; i++ ) {
        //We have to pick from a different font file depending on the character.
        //See note in Font[] definition.
        if(c < 'T')
            line = Font1[font_index + i];
        else
            line = Font2[((c - 'S') * 5) + i];

        //Draw the pixels to screen
        for(j=0; j<7; j++) {
            if(line & 0x01) {
                if(size == 1)
                    //If we are just doing the smallest size font then do a single pixel each
                    draw_pixel(x+i, y+j, colour);
                else
                    //Otherwise do a small box to represent each pixel
                    fill_rectangle(x+(i*size), y+(j*size), x+(i*size)+size, y+(j*size)+size, colour);
            }

            line >>= 1; //Next row of pixels in the font
        }
    }
}

/*
 * Writes a string to the display as an array of chars at position x, y with
 * a given colour and size.
 */
void draw_string(char x, char y, unsigned int colour, char size, char *str) {
    //Work out the size of each character
    int char_width = size * 6;
    //Iterate through each character in the string
    int counter = 0;
    while(str[counter] != '\0') {
        //Calculate character position
        int char_pos = x + (counter * char_width);
        //Write char to the display
        draw_char(char_pos, y, str[counter], colour, size);
        //Next character
        counter++;
    }
}

/* Draws a bitmap array of colours to the display.
 * First two bytes should be width and height respectively.
 * Subsequent bits are uint16 representations of the pixel colours.
 *
 * NOTE: This could be made more efficient by not using the fill_rectangle
 * method. But I didn't need the speed, and it simplified the code a lot.
 */
void draw_bitmap(int x, int y, int scale, unsigned int *bmp) {
    int width = bmp[0];
    int height = bmp[1];
    unsigned int this_byte;
    int this_x;
    int this_y;
    //Set the drawing region
    //set_draw_window(x, y, x+width, y+height);

    //We will do the SPI write manually here for speed
    //CSX low to begin data
    //CSX = 0;
    //Write colour to each pixel
    for(int i = 0; i < height ; i++) {
        for(int j = 0; j < width; j++) {
            this_byte = bmp[(width * i) + j + 2];
            this_x = x + (j * scale);
            this_y = y + (i * scale);
            //Draw the pixel with appropriate scaling
            fill_rectangle(this_x, this_y, this_x + scale, this_y + scale, this_byte);

        }
    }
    //Return CSX to high
    //CSX = 1;
}
